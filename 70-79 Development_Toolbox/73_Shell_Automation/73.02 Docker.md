---
id: 73.02
tags: [type/code, status/growing, context/infrastructure, context/devops]
---

# Docker & Docker Compose

## Overview
Docker is a platform for containerizing applications. Docker Compose (v2) is a plugin for defining and running multi-container applications using YAML files.

> [!NOTE] Docker Compose v2
> Use `docker compose` (space) not `docker-compose` (hyphen). The new version is a Docker CLI plugin.

## Installation

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install docker.io docker-compose-v2

# Or via Docker's official repo
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER  # Run without sudo

# Verify
docker --version
docker compose version
```

## Dockerfile Basics

```dockerfile
# Python app example
FROM python:3.12-slim

WORKDIR /app

# Install dependencies first (cache layer)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Multi-Stage Build
```dockerfile
# Build stage
FROM python:3.12-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt --target=/install

# Production stage
FROM python:3.12-slim
WORKDIR /app
COPY --from=builder /install /usr/local/lib/python3.12/site-packages
COPY . .
CMD ["python", "main.py"]
```

### Common Dockerfile Instructions

| Instruction | Description |
|-------------|-------------|
| `FROM` | Base image |
| `WORKDIR` | Set working directory |
| `COPY` | Copy files into image |
| `RUN` | Execute command during build |
| `ENV` | Set environment variable |
| `EXPOSE` | Document exposed port |
| `CMD` | Default command (can override) |
| `ENTRYPOINT` | Fixed command (args appended) |
| `ARG` | Build-time variable |
| `VOLUME` | Create mount point |

## Docker Commands

```bash
# Build
docker build -t myapp:latest .
docker build -t myapp:v1.0 --build-arg ENV=prod .

# Run
docker run -d -p 8000:8000 --name myapp myapp:latest
docker run -it --rm myapp:latest /bin/sh  # Interactive shell

# Container management
docker ps                    # Running containers
docker ps -a                 # All containers
docker logs myapp            # View logs
docker logs -f myapp         # Follow logs
docker exec -it myapp sh     # Shell into container
docker stop myapp            # Stop container
docker rm myapp              # Remove container

# Images
docker images                # List images
docker rmi myapp:latest      # Remove image
docker image prune           # Remove unused images

# Cleanup
docker system prune -a       # Remove all unused data
```

## Docker Compose

### Basic compose.yaml
```yaml
services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/mydb
    depends_on:
      - db
    volumes:
      - ./app:/app
    restart: unless-stopped

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  postgres_data:
```

### Compose Commands

```bash
docker compose up              # Start services (foreground)
docker compose up -d           # Start services (detached)
docker compose up --build      # Rebuild and start
docker compose down            # Stop and remove containers
docker compose down -v         # Also remove volumes
docker compose logs            # View logs
docker compose logs -f api     # Follow specific service logs
docker compose ps              # List running services
docker compose exec api sh     # Shell into service
docker compose restart api     # Restart service
docker compose pull            # Pull latest images
```

### Full Stack Example
```yaml
# compose.yaml
services:
  # Frontend
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - api

  # Backend API
  api:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/app
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    volumes:
      - ./backend:/app
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Database
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: app
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d app"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Cache
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  # Reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - frontend
      - api

volumes:
  postgres_data:
  redis_data:
```

### Environment Variables
```yaml
services:
  api:
    image: myapp
    # Option 1: Inline
    environment:
      - DEBUG=false
      - API_KEY=secret

    # Option 2: From file
    env_file:
      - .env
      - .env.local
```

```bash
# .env file
DEBUG=false
API_KEY=secret
DATABASE_URL=postgresql://user:pass@db:5432/app
```

### Networks
```yaml
services:
  api:
    networks:
      - frontend
      - backend

  db:
    networks:
      - backend

networks:
  frontend:
  backend:
    internal: true  # No external access
```

### Build Configuration
```yaml
services:
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile.prod
      args:
        - BUILD_ENV=production
      target: production  # Multi-stage target
    image: myapp:${TAG:-latest}
```

### Resource Limits
```yaml
services:
  api:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          memory: 256M
```

### Profiles
```yaml
services:
  api:
    profiles: ["app"]

  db:
    profiles: ["app", "db"]

  debug:
    profiles: ["debug"]
    image: busybox

# Usage
docker compose --profile app up
docker compose --profile debug up
```

## Development vs Production

### Development (compose.yaml)
```yaml
services:
  api:
    build: .
    volumes:
      - ./app:/app  # Hot reload
    environment:
      - DEBUG=true
    command: uvicorn main:app --reload --host 0.0.0.0
```

### Production (compose.prod.yaml)
```yaml
services:
  api:
    image: myregistry/myapp:${TAG}
    restart: always
    environment:
      - DEBUG=false
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
```

```bash
# Merge compose files
docker compose -f compose.yaml -f compose.prod.yaml up -d
```

## Registry & Deployment

```bash
# Login to registry
docker login
docker login ghcr.io  # GitHub Container Registry

# Tag and push
docker build -t myapp:latest .
docker tag myapp:latest ghcr.io/username/myapp:latest
docker push ghcr.io/username/myapp:latest

# Pull and run
docker pull ghcr.io/username/myapp:latest
docker run -d ghcr.io/username/myapp:latest
```

## Best Practices

1. **Use specific image tags** - Avoid `latest` in production
2. **Order Dockerfile layers** - Least changing first for cache
3. **Use .dockerignore** - Exclude unnecessary files
4. **Multi-stage builds** - Smaller production images
5. **Non-root user** - Run as non-root for security
6. **Health checks** - Enable container health monitoring
7. **Resource limits** - Prevent resource exhaustion
8. **Use volumes for data** - Persist important data
9. **One process per container** - Follow microservices pattern
10. **Use compose profiles** - Separate dev/test/prod services

### .dockerignore
```
.git
.gitignore
.env
__pycache__
*.pyc
.pytest_cache
node_modules
.DS_Store
*.md
Dockerfile*
compose*.yaml
```

### Non-root User
```dockerfile
FROM python:3.12-slim

RUN useradd -m appuser
WORKDIR /app
COPY --chown=appuser:appuser . .
USER appuser

CMD ["python", "main.py"]
```

## Debugging

```bash
# View container details
docker inspect myapp

# Check resource usage
docker stats

# View build history
docker history myapp:latest

# Debug failed build
docker build --progress=plain -t myapp .

# Run with shell override
docker run -it --entrypoint /bin/sh myapp

# Copy files from container
docker cp myapp:/app/logs ./logs
```

## Related Concepts
- [[73.01 Nginx]]
- [[71.03 FastAPI]]
- [[21_Infrastructure]]

## References
- Docker Docs: docs.docker.com
- Docker Compose Spec: docs.docker.com/compose/compose-file/
- Best Practices: docs.docker.com/develop/develop-images/dockerfile_best-practices/
