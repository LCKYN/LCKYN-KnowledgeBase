---
id: 72.03
tags: [type/concept, status/growing, context/dev-tools]
---

# Divide-and-Conquer

## Overview

**Divide-and-Conquer** breaks a problem into **multiple** smaller subproblems, solves them recursively, and **combines** their solutions. The key insight is that subproblems are independent and can often be parallelized.

## Key Concepts

- **Divide**: Split problem into smaller subproblems
- **Conquer**: Solve subproblems recursively (base case for small inputs)
- **Combine**: Merge subproblem solutions into final answer

## Master Theorem

For recurrence $T(n) = aT(n/b) + f(n)$:

| Case | Condition | Complexity |
|------|-----------|------------|
| 1 | $f(n) < n^{\log_b a}$ | $O(n^{\log_b a})$ |
| 2 | $f(n) = n^{\log_b a}$ | $O(n^{\log_b a} \log n)$ |
| 3 | $f(n) > n^{\log_b a}$ | $O(f(n))$ |

## Classic Algorithms

| Algorithm | Divide | Conquer | Combine | Time |
|-----------|--------|---------|---------|------|
| **Merge Sort** | Split in half | Sort halves | Merge | $O(n \log n)$ |
| **Quick Sort** | Partition by pivot | Sort partitions | None | $O(n \log n)$ avg |
| **Binary Search** | Pick half | Search half | None | $O(\log n)$ |
| **Strassen's** | Split matrix | 7 multiplies | Combine | $O(n^{2.81})$ |
| **Karatsuba** | Split digits | 3 multiplies | Combine | $O(n^{1.58})$ |
| **Closest Pair** | Split by x | Solve halves | Check strip | $O(n \log n)$ |

## Template Pattern

```
function divideAndConquer(problem):
    if problem is small enough:
        return baseCaseSolution(problem)

    subproblems = divide(problem)
    solutions = [divideAndConquer(sub) for sub in subproblems]
    return combine(solutions)
```

## When to Use

| Good Fit | Poor Fit |
|----------|----------|
| Problem naturally splits | Overlapping subproblems (use DP) |
| Subproblems independent | Sequential dependencies |
| Combine step is efficient | Expensive merge operation |

> [!WARNING]
> If subproblems overlap significantly, Divide-and-Conquer leads to redundant work. Use [[72.06 Dynamic Programming]] instead.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.02 Decrease-and-Conquer]]
- [[72.06 Dynamic Programming]]
- [[72.18 Sorting Algorithms Comparison]]
