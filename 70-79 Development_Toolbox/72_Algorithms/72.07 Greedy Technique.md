---
id: 72.07
tags: [type/concept, status/evergreen, context/dev-tools]
---

# Greedy Technique

## Overview

**Greedy** algorithms make the **locally optimal choice** at each step, hoping to find a global optimum. They build solutions incrementally, never reconsidering past decisions. Fast and simple, but only work when greedy choice property holds.

## Key Concepts

| Concept | Description |
|---------|-------------|
| **Greedy Choice Property** | Local optimal choice leads to global optimum |
| **Optimal Substructure** | Optimal solution contains optimal sub-solutions |
| **Irrevocable Decisions** | Once a choice is made, never backtrack |
| **Feasibility** | Each step must satisfy problem constraints |

## When Greedy Works

> [!WARNING] Greedy Pitfall
> Greedy doesn't always work! Must prove greedy choice property. Counter-example: 0/1 Knapsack (greedy fails), Fractional Knapsack (greedy works).

| Condition | Required |
|-----------|----------|
| Greedy choice property | ✅ Must prove |
| Optimal substructure | ✅ Must have |
| No future impact | Choices don't affect future options negatively |

## Classic Greedy Algorithms

| Algorithm | Problem | Greedy Choice | Time |
|-----------|---------|---------------|------|
| **Dijkstra** | Shortest path | Nearest unvisited vertex | $O(E \log V)$ |
| **Prim/Kruskal** | MST | Minimum weight edge | $O(E \log V)$ |
| **Huffman** | Optimal prefix codes | Merge lowest frequency | $O(n \log n)$ |
| **Activity Selection** | Max non-overlapping | Earliest finish time | $O(n \log n)$ |
| **Fractional Knapsack** | Max value/weight | Highest value density | $O(n \log n)$ |

## Greedy vs Other Paradigms

| Paradigm | Decision Style | Guarantee |
|----------|----------------|-----------|
| **Greedy** | Local best, no backtrack | Optimal only if property holds |
| **Dynamic Programming** | Consider all subproblems | Always optimal |
| **Backtracking** | Try, undo if fails | Explores all possibilities |
| **Iterative Improvement** | Start complete, refine | Local optimum |

## Proof Techniques

To prove greedy works:

1. **Exchange Argument**: Show greedy choice can replace any optimal choice without worsening
2. **Greedy Stays Ahead**: Show greedy is at least as good as optimal at each step
3. **Structural**: Show problem has matroid structure

## Activity Selection Example

Given activities with start/end times, select maximum non-overlapping:

| Strategy | Result |
|----------|--------|
| Earliest start ❌ | May block many others |
| Shortest duration ❌ | May conflict with many |
| **Earliest finish ✅** | Leaves maximum room for others |

## Practical Use Cases

| Application | Algorithm |
|-------------|-----------|
| Network routing | Dijkstra's shortest path |
| Compression | Huffman coding |
| Scheduling | Activity selection, job sequencing |
| Network design | Minimum spanning tree |
| Making change | Coin selection (canonical systems) |

> [!TIP] When to Suspect Greedy
> Problems asking for "minimum/maximum" with constraints, where choices don't depend on future decisions. Try greedy first, verify with counter-examples.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.06 Dynamic Programming]] - Use when greedy fails
- [[72.08 Iterative Improvement]] - Refine vs build incrementally
- [[72.01 Brute Force and Exhaustive Search]] - Explores all, greedy prunes
- [[72.13 Graph Algorithms]] - Dijkstra, Prim, Kruskal
