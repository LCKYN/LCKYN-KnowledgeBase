---
id: 72.06
tags: [type/concept, status/growing, context/dev-tools]
---

# Dynamic Programming

## Overview

**Dynamic Programming (DP)** solves problems by breaking them into overlapping subproblems, solving each **once**, and storing results. It transforms exponential brute-force into polynomial time by eliminating redundant computation.

## Key Concepts

- **Optimal Substructure**: Optimal solution contains optimal solutions to subproblems
- **Overlapping Subproblems**: Same subproblems recur multiple times
- **Memoization**: Top-down caching of results
- **Tabulation**: Bottom-up iterative filling

## Two Approaches

| Approach | Direction | Style | Pros |
|----------|-----------|-------|------|
| **Memoization** | Top-down | Recursive + cache | Natural, only computes needed |
| **Tabulation** | Bottom-up | Iterative | No recursion overhead, space optimization |

## DP Recipe

1. **Define State**: What subproblem does `dp[i]` represent?
2. **Recurrence Relation**: How does `dp[i]` relate to smaller states?
3. **Base Case**: What are the trivial solutions?
4. **Computation Order**: Ensure dependencies computed first
5. **Answer Extraction**: Where is final answer stored?

## Classic Problems

| Problem | State | Recurrence | Time |
|---------|-------|------------|------|
| **Fibonacci** | `dp[i]` = i-th fib | `dp[i] = dp[i-1] + dp[i-2]` | $O(n)$ |
| **0/1 Knapsack** | `dp[i][w]` = max value | `max(skip, take)` | $O(nW)$ |
| **LCS** | `dp[i][j]` = LCS length | match or skip | $O(nm)$ |
| **Edit Distance** | `dp[i][j]` = min edits | insert/delete/replace | $O(nm)$ |
| **Longest Increasing Subsequence** | `dp[i]` = LIS ending at i | `max(dp[j]) + 1` | $O(n^2)$ or $O(n \log n)$ |
| **Coin Change** | `dp[i]` = min coins for i | `min(dp[i-coin]) + 1` | $O(nS)$ |

## Space Optimization

| Technique | When | Example |
|-----------|------|--------|
| **Rolling Array** | Only need previous row | Knapsack: 2D → 1D |
| **Two Variables** | Only need last 2 values | Fibonacci: O(1) space |
| **In-place** | Can overwrite safely | Some grid problems |

## DP vs Other Paradigms

| Paradigm | Subproblems | Overlap | Typical |
|----------|-------------|---------|--------|
| **Divide & Conquer** | Independent | No | Merge Sort |
| **Dynamic Programming** | Dependent | Yes | Knapsack |
| **Greedy** | Local choice | N/A | Huffman |

> [!TIP]
> If you see "optimal", "minimum", "maximum", "count ways" → think DP. Draw the recursion tree—if you see repeated nodes, memoize.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.03 Divide-and-Conquer]] - Use when subproblems don't overlap
- [[72.07 Greedy Technique]] - Use when local choice is globally optimal
- [[72.05 Space and Time Trade-Offs]] - Memoization trades space for time
- [[72.01 Brute Force and Exhaustive Search]] - Exponential approach DP optimizes
- [[72.20 Edit Distance]] - Classic DP application
