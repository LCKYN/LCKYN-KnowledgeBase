---
id: 72.04
tags: [type/concept, status/evergreen, context/dev-tools]
---

# Transform-and-Conquer

## Overview

**Transform-and-Conquer** is an algorithm design strategy that solves a problem by first transforming it into a different form (or a simpler instance), then solving the transformed version. The key insight: sometimes it's easier to transform the problem than to solve it directly.

## Key Concepts

Three main transformation types:

| Transformation Type | Description | Example |
|---------------------|-------------|---------|
| **Instance Simplification** | Transform to simpler/more convenient instance of same problem | Presorting before searching |
| **Representation Change** | Change data representation to enable efficient operations | Use heap instead of array for priority queue |
| **Problem Reduction** | Reduce to a different problem with known solution | LCM via GCD: $\text{lcm}(a,b) = \frac{a \cdot b}{\gcd(a,b)}$ |

## Techniques

### Presorting

> [!TIP] When to presort
> If you need multiple queries on same data (element uniqueness, finding pairs), sort first: $O(n \log n)$ once beats $O(n^2)$ repeated scans.

- **Element Uniqueness**: Sort → check adjacent pairs → $O(n \log n)$
- **Mode Finding**: Sort → count consecutive runs
- **Closest Pair in 1D**: Sort → check adjacent differences

### Balanced Search Trees (BST → AVL/Red-Black)

Transform unbalanced BST into self-balancing structure:

| Tree Type | Search | Insert | Delete | Use Case |
|-----------|--------|--------|--------|----------|
| BST (unbalanced) | $O(n)$ worst | $O(n)$ | $O(n)$ | Rarely used alone |
| AVL Tree | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | Read-heavy workloads |
| Red-Black Tree | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | General purpose (std::map) |

### Heaps and Heapsort

Transform array into heap structure for efficient priority access:

```
Heap property: parent ≥ children (max-heap)
Build heap: O(n) via bottom-up heapify
Extract max: O(log n)
```

### Gaussian Elimination

Transform system of equations to row-echelon form:
- $Ax = b$ → $Ux = c$ (upper triangular)
- Back-substitution: $O(n)$ after $O(n^3)$ transformation

## Comparison: Direct vs Transform-and-Conquer

| Problem | Direct Approach | Transform-and-Conquer |
|---------|-----------------|----------------------|
| Find duplicates | $O(n^2)$ pairwise comparison | $O(n \log n)$ presort + scan |
| Priority queue | $O(n)$ find-min in array | $O(\log n)$ with heap |
| Range queries | $O(n)$ per query | $O(\log n)$ with BST/segment tree |

## Practical Use Cases

- **Database indexing**: Transform unsorted data → B-tree for fast lookups
- **Scheduling**: Heap for job priority management
- **Computational geometry**: Presort points for sweep-line algorithms

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.05 Space and Time Trade-Offs]] - Precomputation as transformation
- [[72.16 Heap and Priority Queue]] - Representation change example
- [[72.24 Heap Sort]] - Uses heap transformation
- [[72.01 Brute Force and Exhaustive Search]] - Direct approach that transform avoids
