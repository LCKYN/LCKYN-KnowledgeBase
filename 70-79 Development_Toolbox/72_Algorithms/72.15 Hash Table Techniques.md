---
id: 72.15
tags: [type/concept, status/evergreen, context/dev-tools]
---

# Hash Table Techniques

**Hash tables** provide $O(1)$ average-time complexity for insert, lookup, and delete operations by mapping keys to array indices via a hash function.

## Core Components

| Component | Purpose |
|-----------|---------|
| Hash function | Maps key → index |
| Buckets/Slots | Array positions storing values |
| Collision handling | Strategy when two keys hash to same index |
| Load factor | $\frac{\text{items}}{\text{buckets}}$ — triggers resize |

## Hash Function Properties

> [!INFO] Good Hash Functions
> - **Deterministic**: Same input → same output
> - **Uniform distribution**: Spread keys evenly
> - **Fast computation**: O(1) time
> - **Avalanche effect**: Small input change → large output change

## Collision Handling

| Method | Description | Pros | Cons |
|--------|-------------|------|------|
| Chaining | Linked list at each bucket | Simple, handles high load | Extra memory for pointers |
| Open Addressing | Find next empty slot | Cache-friendly | Clustering, complex delete |
| Linear Probing | Check next slot sequentially | Simple | Primary clustering |
| Quadratic Probing | Check $+1, +4, +9, ...$ | Less clustering | Secondary clustering |
| Double Hashing | Use second hash function | Minimal clustering | More computation |

## Complexity Analysis

| Operation | Average | Worst (poor hash) |
|-----------|---------|-------------------|
| Insert | $O(1)$ | $O(n)$ |
| Lookup | $O(1)$ | $O(n)$ |
| Delete | $O(1)$ | $O(n)$ |
| Space | $O(n)$ | $O(n)$ |

## Common Patterns in Coding Problems

| Pattern | Use Case | Example |
|---------|----------|---------|
| Frequency count | Count occurrences | `Counter(arr)` |
| Two Sum | Find pair with target sum | Map value → index |
| Grouping | Group anagrams, by key | `defaultdict(list)` |
| Caching/Memoization | Store computed results | `@lru_cache` |
| Deduplication | Remove duplicates | `set(arr)` |
| Existence check | Fast membership test | `if x in seen` |

## Python Implementation

```python
# Frequency count
from collections import Counter
freq = Counter(arr)

# Two Sum pattern
seen = {}
for i, num in enumerate(arr):
    complement = target - num
    if complement in seen:
        return [seen[complement], i]
    seen[num] = i

# Grouping pattern
from collections import defaultdict
groups = defaultdict(list)
for item in items:
    key = get_key(item)
    groups[key].append(item)
```

## Load Factor & Resizing

| Load Factor | Performance | Action |
|-------------|-------------|--------|
| < 0.5 | Excellent | Optimal range |
| 0.5 - 0.75 | Good | Typical threshold |
| > 0.75 | Degrading | Trigger resize (2x) |
| > 1.0 | Poor (chaining) | Many collisions |

> [!TIP] Resize Strategy
> When load factor exceeds threshold, create new array (2x size) and rehash all keys.

## Related Concepts

- [[72_Algorithms_MOC]] - parent category
- [[72.01 Brute Force and Exhaustive Search]] - hash tables optimize brute force lookups
