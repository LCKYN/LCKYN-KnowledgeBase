---
id: 72.01
tags: [type/concept, status/growing, context/dev-tools]
---

# Brute Force and Exhaustive Search

## Overview

**Brute Force** is a straightforward problem-solving approach that systematically enumerates all possible candidates and checks each one. It guarantees finding a solution if one exists, trading efficiency for simplicity and correctness.

## Key Concepts

- **Exhaustive Search**: Explore entire solution space systematically
- **Generate and Test**: Create candidates, then validate against constraints
- **No Heuristics**: Makes no assumptions about solution structure
- **Guaranteed Completeness**: Will find solution if it exists

## When to Use

| Scenario | Reason |
|----------|--------|
| Small input size | Overhead of optimization not worth it |
| Correctness critical | Verify optimized solutions |
| No pattern visible | Starting point before optimization |
| One-time computation | Development speed > runtime |

## Common Techniques

| Technique | Description | Example |
|-----------|-------------|---------|
| **Linear Search** | Check each element sequentially | Find item in unsorted list |
| **String Matching** | Compare pattern at each position | Naive substring search |
| **Permutation Generation** | Try all orderings | TSP, scheduling |
| **Subset Enumeration** | Try all combinations | Knapsack, subset sum |
| **Nested Loops** | Check all pairs/triples | Closest pair (naive) |

## Complexity Analysis

| Problem Type | Time Complexity |
|--------------|----------------|
| Linear search | $O(n)$ |
| Pair checking | $O(n^2)$ |
| Permutations | $O(n!)$ |
| Subsets | $O(2^n)$ |

> [!TIP]
> Use brute force first to establish correctness, then optimize. A working $O(n^2)$ solution beats a broken $O(n \log n)$ one.

## Evolution to Smarter Strategies

Brute Force is the **baseline** from which more efficient paradigms evolve:

| Paradigm | How It Improves Over Brute Force |
|----------|----------------------------------|
| **Decrease-and-Conquer** | Reduces problem size by a constant (e.g., eliminate one element per step instead of checking all) |
| **Divide-and-Conquer** | Splits problem in half, discards irrelevant portions (e.g., binary search vs linear scan) |
| **Dynamic Programming** | Avoids redundant recomputation by memoizing subproblems |
| **Greedy** | Makes locally optimal choices instead of exploring all options |

> [!INFO] Why Link to These?
> Understanding brute force helps recognize **what work is being saved** by smarter strategies. Every optimization is a brute force approach with pruned search space.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.02 Decrease-and-Conquer]]
- [[72.03 Divide-and-Conquer]]
- [[72.06 Dynamic Programming]]
- [[72.07 Greedy Technique]]
