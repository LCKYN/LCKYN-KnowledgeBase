---
id: 72.01
tags: [type/concept, status/growing, context/dev-tools]
---

# Brute Force and Exhaustive Search

## Overview

**Brute Force** is a straightforward problem-solving approach that systematically enumerates all possible candidates and checks each one. It guarantees finding a solution if one exists, trading efficiency for simplicity and correctness.

## Key Concepts

- **Exhaustive Search**: Explore entire solution space systematically
- **Generate and Test**: Create candidates, then validate against constraints
- **No Heuristics**: Makes no assumptions about solution structure
- **Guaranteed Completeness**: Will find solution if it exists

## When to Use

| Scenario | Reason |
|----------|--------|
| Small input size | Overhead of optimization not worth it |
| Correctness critical | Verify optimized solutions |
| No pattern visible | Starting point before optimization |
| One-time computation | Development speed > runtime |

## Common Techniques

| Technique | Description | Example |
|-----------|-------------|---------|
| **Linear Search** | Check each element sequentially | Find item in unsorted list |
| **String Matching** | Compare pattern at each position | Naive substring search |
| **Permutation Generation** | Try all orderings | TSP, scheduling |
| **Subset Enumeration** | Try all combinations | Knapsack, subset sum |
| **Nested Loops** | Check all pairs/triples | Closest pair (naive) |

## Complexity Analysis

| Problem Type | Time Complexity |
|--------------|----------------|
| Linear search | $O(n)$ |
| Pair checking | $O(n^2)$ |
| Permutations | $O(n!)$ |
| Subsets | $O(2^n)$ |

> [!TIP]
> Use brute force first to establish correctness, then optimize. A working $O(n^2)$ solution beats a broken $O(n \log n)$ one.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.02 Decrease-and-Conquer]]
- [[72.03 Divide-and-Conquer]]
