---
id: 72.21
tags: [type/concept, status/evergreen, context/dev-tools]
---

# Quick Sort

## Overview

**Quick Sort** is a divide-and-conquer sorting algorithm that selects a **pivot** element, partitions the array into elements less than and greater than the pivot, then recursively sorts the partitions. Average $O(n \log n)$ with excellent cache performance.

## Key Concepts

| Term | Definition |
|------|------------|
| **Pivot** | Element used to partition the array |
| **Partition** | Rearranging so elements < pivot are left, > pivot are right |
| **In-place** | Uses $O(\log n)$ stack space, no extra array |
| **Unstable** | Equal elements may change relative order |

## Algorithm Steps

```mermaid
graph TD
    A[Choose Pivot] --> B[Partition Array]
    B --> C[Elements < Pivot | Pivot | Elements > Pivot]
    C --> D[Recursively Sort Left]
    C --> E[Recursively Sort Right]
    D --> F[Combined Sorted Array]
    E --> F
```

1. **Choose pivot** (first, last, random, or median-of-three)
2. **Partition**: Move smaller elements left, larger right
3. **Recurse**: Sort left and right partitions
4. **Base case**: Subarray of 0-1 elements

## Partition Schemes

| Scheme | Description | Pros | Cons |
|--------|-------------|------|------|
| **Lomuto** | Single pointer, pivot at end | Simple implementation | More swaps, bad on duplicates |
| **Hoare** | Two pointers from ends | Fewer swaps | Slightly complex |
| **Three-way** | Dutch flag partitioning | Handles duplicates well | Extra complexity |

## Complexity Analysis

| Case | Time | When |
|------|------|------|
| Best | $O(n \log n)$ | Pivot splits evenly |
| Average | $O(n \log n)$ | Random pivot |
| Worst | $O(n^2)$ | Already sorted + bad pivot |
| Space | $O(\log n)$ | Recursion stack (best/avg) |

> [!WARNING] Worst Case Trigger
> Naive first/last pivot on sorted data â†’ $O(n^2)$. Always use **randomized pivot** or **median-of-three**.

## Optimizations

| Technique | Benefit |
|-----------|---------|
| **Median-of-three** | Better pivot selection, avoids worst case |
| **Randomized pivot** | Probabilistically avoids worst case |
| **Insertion sort cutoff** | Switch to insertion sort for $n < 10$ |
| **Tail recursion** | Reduce stack depth to $O(\log n)$ |
| **Three-way partition** | Linear time on many duplicates |

## Pseudocode

```
quicksort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quicksort(arr, low, pivot_idx - 1)
        quicksort(arr, pivot_idx + 1, high)

partition(arr, low, high):
    pivot = arr[high]  # Lomuto scheme
    i = low - 1
    for j = low to high - 1:
        if arr[j] <= pivot:
            i += 1
            swap(arr[i], arr[j])
    swap(arr[i + 1], arr[high])
    return i + 1
```

## When to Use

| Good Fit | Poor Fit |
|----------|----------|
| General-purpose sorting | Stability required |
| In-memory sorting | Already sorted data (without random pivot) |
| Cache performance matters | Linked lists (poor locality) |
| Average case acceptable | Guaranteed $O(n \log n)$ needed |

> [!TIP] Production Use
> Modern implementations use **Introsort**: Quick Sort with fallback to Heap Sort when recursion depth exceeds $2 \log n$, guaranteeing $O(n \log n)$ worst case.

## Quick Select Variant

**Quick Select** finds the k-th smallest element in $O(n)$ average time using partitioning without full sorting:

| Algorithm | Time (avg) | Use Case |
|-----------|------------|----------|
| Quick Select | $O(n)$ | Find k-th element |
| Median of Medians | $O(n)$ guaranteed | Worst-case linear selection |

## Related Concepts

- [[72_Algorithms_MOC]] - Parent category
- [[72.03 Divide-and-Conquer]] - Paradigm: partition and recurse
- [[72.18 Sorting Algorithms Comparison]] - Context: when to choose quick sort
- [[72.22 Merge Sort]] - Contrast: stable O(n log n) alternative
