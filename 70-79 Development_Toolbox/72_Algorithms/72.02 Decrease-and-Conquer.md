---
id: 72.02
tags: [type/concept, status/growing, context/dev-tools]
---

# Decrease-and-Conquer

## Overview

**Decrease-and-Conquer** solves problems by reducing them to smaller instances of the same problem. Unlike Divide-and-Conquer which splits into multiple subproblems, this reduces to **one** smaller subproblem.

## Key Concepts

- **Single Subproblem**: Reduce to one smaller instance (not multiple)
- **Three Variants**: Decrease by constant, factor, or variable
- **Recursive or Iterative**: Can implement either way

## Decrease Variants

| Variant | Reduction | Example |
|---------|-----------|--------|
| **By Constant** | $n \to n-1$ | Insertion Sort, factorial |
| **By Factor** | $n \to n/k$ | Binary Search, exponentiation |
| **By Variable** | $n \to n-f(n)$ | Euclid's GCD |

## Classic Algorithms

| Algorithm | Type | Time | Description |
|-----------|------|------|-------------|
| **Binary Search** | By half | $O(\log n)$ | Eliminate half each step |
| **Insertion Sort** | By one | $O(n^2)$ | Insert into sorted subarray |
| **Euclid's GCD** | Variable | $O(\log n)$ | $\gcd(a,b) = \gcd(b, a \mod b)$ |
| **Exponentiation** | By half | $O(\log n)$ | $a^n = (a^{n/2})^2$ |
| **Selection Sort** | By one | $O(n^2)$ | Find min, reduce size |

## vs Divide-and-Conquer

| Aspect | Decrease-and-Conquer | Divide-and-Conquer |
|--------|---------------------|--------------------|
| Subproblems | **One** | Multiple |
| Example | Binary Search | Merge Sort |
| Recurrence | $T(n) = T(n-1) + f(n)$ | $T(n) = aT(n/b) + f(n)$ |

> [!TIP]
> If you're solving one smaller problem → Decrease-and-Conquer. If you're combining solutions from multiple subproblems → Divide-and-Conquer.

## Related Concepts

- [[72_Algorithms_MOC]]
- [[72.01 Brute Force and Exhaustive Search]]
- [[72.03 Divide-and-Conquer]]
- [[72.17 Binary Search Patterns]]
