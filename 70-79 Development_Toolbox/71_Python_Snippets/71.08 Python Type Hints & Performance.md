---
id: 71.08
tags: [type/concept, status/evergreen, context/python]
---

# Python Type Hints & Performance

## The Core Answer

> [!INFO] Short answer
> Python has **type hints**, NOT true static types. By default, type hints are **completely ignored at runtime** — they have zero effect on execution speed. BUT: there are specific tools and features where type information **does** affect performance.

| Scenario | Does Typing Help Performance? |
|---|---|
| Vanilla Python with type hints | ❌ No — annotations ignored at runtime |
| Python 3.14 with PEP 649 | ✅ Yes — faster import/startup time |
| Compiled with `mypyc` | ✅ Yes — 2–10× speedup from C compilation |
| Runtime checked with `beartype` | ⚠️ Adds overhead but validates correctness |
| AOT compiled with `Cython` | ✅ Yes — explicit `cdef` types give C-speed |

---

## Python Has Type Hints, Not Static Types

Unlike C, Rust, or Java, Python types are **annotations** — metadata attached to variables and functions. The Python interpreter **does not use them** during execution by default.

```python
def add(a: int, b: int) -> int:
    return a + b

add(1, 2)        # works, type-checked = correct
add("x", "y")   # also works at runtime — no error! type hint is just a hint
```

At runtime, annotations are stored in `__annotations__` — a plain dict. They are **not enforced** unless you explicitly use a type checker or runtime validator.

```python
>>> add.__annotations__
{'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}
```

---

## PEP 649 (Python 3.14) — Lazy Annotation Evaluation

**What changed**: Before 3.14, annotation *expressions* were evaluated eagerly when the function/class was defined. PEP 649 makes them **lazily evaluated** — only computed when accessed.

### Performance Impact: Startup Time

```python
# Python < 3.14 — annotation evaluated at class definition time
class Order:
    amount: Decimal               # Decimal evaluated immediately at import time
    items: list[OrderItem]        # list[OrderItem] evaluated immediately
    metadata: dict[str, Any]      # dict[str, Any] evaluated immediately
```

With many annotated classes, this adds up at import time. In 3.14:

```python
# Python 3.14 — annotations are lazy objects, evaluated only when accessed
class Order:
    amount: Decimal               # annotation NOT evaluated at import time
    items: list[OrderItem]        # evaluated only if you call get_type_hints()
```

**Practical impact**: faster module imports, especially in codebases with many type-annotated classes and complex generic types.

### Before PEP 649 — The Old Workaround

```python
# Python 3.10–3.13: use this to get the same lazy behavior
from __future__ import annotations   # PEP 563 — stores annotations as strings

class Order:
    amount: Decimal   # stored as the string "Decimal", not evaluated
```

PEP 649 in 3.14 replaces this with a proper language mechanism — no import needed.

---

## When Type Hints DO Affect Runtime Performance

### 1. `mypyc` — Compile Annotated Python to C

`mypyc` is part of the mypy project. It reads type annotations and compiles Python modules to **C extensions** — the same mechanism as writing a `.pyd` / `.so` file by hand.

| Use case | Speedup |
|---|---|
| Pure computation loops | 2–10× |
| Data processing | 2–5× |
| I/O-bound code | Minimal (waiting on I/O isn't CPU) |

```bash
pip install mypy
mypyc my_module.py          # produces my_module.cpython-314-darwin.so
python -c "import my_module" # uses the compiled version automatically
```

> [!TIP] mypyc sweet spot
> Best for CPU-bound modules with tight loops and well-typed numeric code. Used internally by mypy itself (mypy is partially compiled with mypyc).

### 2. `beartype` — Fast Runtime Type Enforcement

`beartype` is a **zero-overhead-by-design** runtime type checker. It uses annotations to generate type-checking code at decoration time (not per-call introspection).

```python
from beartype import beartype

@beartype
def calculate(amount: float, rate: float) -> float:
    return amount * rate

calculate(100.0, 1.5)    # ✅ fast — O(1) check
calculate("x", 1.5)      # ❌ raises BeartypeCallHintParamViolation immediately
```

- Slower than untyped code (adds a check), but ~100–1000× faster than `typeguard`
- Useful to catch type bugs in production without full test coverage

### 3. `Cython` — Explicit Static Types for C Speeds

Cython extends Python syntax with C type declarations. Unlike mypyc, you explicitly annotate with C types:

```cython
# fast_math.pyx
def sum_array(double[:] arr, int n) -> double:
    cdef double total = 0.0
    cdef int i
    for i in range(n):
        total += arr[i]
    return total
```

- Compiled to C — near-native speed for numeric loops
- Python type hints (`float`) are different from Cython `cdef double` — Cython has its own type system

### 4. Free-Threading (Python 3.13+/3.14) + Type Annotations

Python 3.14 ships with the free-threaded build (no GIL) as a first-class feature. Type annotations help here **indirectly**: well-typed code is easier to reason about for thread safety, and tools like `mypyc` can generate thread-safe C code.

---

## What Does NOT Help

| Claim | Reality |
|---|---|
| "Adding type hints makes my code faster" | ❌ No — hints are metadata, not instructions |
| "Using `int` instead of `Any` speeds up arithmetic" | ❌ No — Python always uses PyObject internally |
| "Pydantic models are faster than dicts because of types" | ⚠️ Partially — Pydantic v2 uses Rust internally, not because of types |
| "`from __future__ import annotations` speeds up my loops" | ❌ No — only affects import/startup, not execution |

---

## Summary Decision Tree

```
Do you need faster Python?
    │
    ├─ Startup / import time slow?
    │     └─ ✅ Use Python 3.14 (PEP 649 lazy annotations) or
    │           `from __future__ import annotations`
    │
    ├─ CPU-bound computation loop?
    │     └─ ✅ Compile with mypyc (easy) or Cython (more control)
    │           Also consider: numpy, PyPy, Rust via PyO3
    │
    ├─ Want runtime type safety with speed?
    │     └─ ✅ Use @beartype
    │
    └─ I/O bound (network, DB, filesystem)?
          └─ ❌ Type hints won't help — use async/await, connection pooling
```

---

## Related Concepts
- [[71_Python_Snippets_MOC]] - Parent category
- [[71.01 Python 3.14 New Features]] - PEP 649 and deferred annotations context
- [[71.06 Python Clean Code]] - Type hints as documentation and intent signals
- [[71.05 Programmer Performance Micro-Techniques]] - Other performance techniques
- [[11.25 Writing Code That AI Assistants Understand]] - Type hints help Copilot accuracy
