---
id: 71.07
tags: [type/concept, status/evergreen, context/dev-tools]
---

# SOLID Principles

## Overview
**SOLID** is a set of five object-oriented design principles that produce software that is easier to maintain, extend, and test. Originally formulated by Robert C. Martin ("Uncle Bob").

| Letter | Principle | One-Liner |
|---|---|---|
| **S** | Single Responsibility | A class has one reason to change |
| **O** | Open/Closed | Open for extension, closed for modification |
| **L** | Liskov Substitution | Subtypes must be substitutable for their base type |
| **I** | Interface Segregation | Many specific interfaces > one fat interface |
| **D** | Dependency Inversion | Depend on abstractions, not concretions |

---

## S — Single Responsibility Principle

> *A class should have only one reason to change.*

**Problem**: A class that does too much has multiple reasons to change — changes to any one concern break the others.

```python
# ❌ Violates SRP — handles business logic, persistence, AND formatting
class Order:
    def calculate_total(self): ...
    def save_to_db(self): ...
    def format_as_html(self): ...

# ✅ Each class has one responsibility
class Order:
    def calculate_total(self) -> float: ...

class OrderRepository:
    def save(self, order: Order) -> None: ...

class OrderHTMLFormatter:
    def render(self, order: Order) -> str: ...
```

> [!TIP] Diagnostic question
> "What does this class do?" — if the honest answer includes "and", it likely violates SRP.

---

## O — Open/Closed Principle

> *Software entities should be open for extension, but closed for modification.*

Extend behavior by **adding new code** (subclasses, new implementations), not by editing existing code.

```python
# ❌ Violates OCP — adding a new payment method requires editing this function
def process_payment(method: str, amount: float):
    if method == "stripe":    do_stripe(amount)
    elif method == "paypal":  do_paypal(amount)
    # Adding "crypto" means editing here

# ✅ OCP via abstraction — new methods just add a new class
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def charge(self, amount: float) -> None: ...

class StripeProcessor(PaymentProcessor):
    def charge(self, amount: float) -> None: ...

class PayPalProcessor(PaymentProcessor):
    def charge(self, amount: float) -> None: ...

class CryptoProcessor(PaymentProcessor):   # extension, no existing code changed
    def charge(self, amount: float) -> None: ...

def process_payment(processor: PaymentProcessor, amount: float):
    processor.charge(amount)   # closed for modification
```

---

## L — Liskov Substitution Principle

> *Objects of a subclass should be usable anywhere the parent class is expected, without breaking correctness.*

**Violated when** a subclass: raises unexpected exceptions, weakens preconditions, strengthens postconditions, or changes observable behavior.

```python
# ❌ Violates LSP — Square breaks Rectangle's invariant
class Rectangle:
    def set_width(self, w): self.width = w
    def set_height(self, h): self.height = h
    def area(self): return self.width * self.height

class Square(Rectangle):
    def set_width(self, w):
        self.width = w
        self.height = w   # ← breaks caller's assumption that w and h are independent

# ✅ LSP — use a common Shape abstraction instead of inheritance
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self) -> float: ...

class Rectangle(Shape):
    def __init__(self, w: float, h: float): ...
    def area(self) -> float: return self.width * self.height

class Square(Shape):
    def __init__(self, side: float): ...
    def area(self) -> float: return self.side ** 2
```

> [!WARNING] The "is-a" trap
> "A square IS-A rectangle" is true in math but LSP-violating in code if Rectangle is mutable. Inheritance should model **behavioral** substitutability, not just semantic taxonomy.

---

## I — Interface Segregation Principle

> *Clients should not be forced to depend on interfaces they do not use.*

Fat interfaces force implementors to write stub/dummy methods they don't need — a sign the interface should be split.

```python
# ❌ Violates ISP — a read-only client is forced to implement write methods
class Storage(ABC):
    @abstractmethod
    def read(self, key: str) -> bytes: ...
    @abstractmethod
    def write(self, key: str, data: bytes) -> None: ...
    @abstractmethod
    def delete(self, key: str) -> None: ...
    @abstractmethod
    def list_keys(self) -> list[str]: ...

class ReadOnlyCache(Storage):
    def write(self, key, data): raise NotImplementedError   # ← forced stub

# ✅ Segregated interfaces
class Readable(ABC):
    @abstractmethod
    def read(self, key: str) -> bytes: ...

class Writable(ABC):
    @abstractmethod
    def write(self, key: str, data: bytes) -> None: ...

class FullStorage(Readable, Writable):    # compose only what you need
    ...

class ReadOnlyCache(Readable):            # no forced stubs
    def read(self, key: str) -> bytes: ...
```

> [!TIP] Python note
> Python uses **duck typing** and **Protocols** (`typing.Protocol`) instead of explicit interfaces — ISP applies equally: keep `Protocol` definitions narrow and composable.

```python
from typing import Protocol

class Readable(Protocol):
    def read(self, key: str) -> bytes: ...

class Writable(Protocol):
    def write(self, key: str, data: bytes) -> None: ...
```

---

## D — Dependency Inversion Principle

> *High-level modules should not depend on low-level modules. Both should depend on abstractions.*

**Concretely**: inject dependencies rather than instantiating them internally.

```python
# ❌ Violates DIP — high-level OrderService depends on low-level MySQLRepository
class OrderService:
    def __init__(self):
        self.repo = MySQLOrderRepository()  # ← hard-coded concrete dependency

    def create_order(self, data): self.repo.save(Order(data))

# ✅ DIP — depend on the abstraction; inject the concrete at the boundary
class OrderRepository(Protocol):
    def save(self, order: Order) -> None: ...

class OrderService:
    def __init__(self, repo: OrderRepository):   # ← injected
        self.repo = repo

    def create_order(self, data): self.repo.save(Order(data))

# Wiring (e.g., in main.py or DI container)
service = OrderService(repo=MySQLOrderRepository())
# or in tests:
service = OrderService(repo=InMemoryOrderRepository())
```

> [!TIP] DIP enables testability
> When high-level code depends on abstractions, you can swap in mock/fake implementations for testing without touching production code.

---

## SOLID in Python — Common Patterns

| SOLID | Python Mechanism |
|---|---|
| SRP | Small focused classes; avoid God objects |
| OCP | `ABC` + `abstractmethod`; `Protocol`; strategy pattern |
| LSP | Test subtypes with the same test suite as the parent |
| ISP | Narrow `Protocol` types; mixin composition |
| DIP | Constructor injection; `typing.Protocol` as abstraction layer |

---

## Anti-Patterns Checklist

| Smell | Likely SOLID Violation |
|---|---|
| Class with many unrelated methods | SRP |
| `if isinstance(x, ConcreteA): ... elif isinstance(): ...` | OCP |
| Subclass raises `NotImplementedError` on inherited method | LSP or ISP |
| Method does nothing / raises `NotImplementedError` | ISP |
| `from module import ConcreteClass` used directly in business logic | DIP |

## Related Concepts
- [[71_Python_Snippets_MOC]] - Parent category
- [[71.06 Python Clean Code]] - Clean code naming and function design complement SOLID
- [[71.04 Google Python Style Guide]] - Google's Python conventions
