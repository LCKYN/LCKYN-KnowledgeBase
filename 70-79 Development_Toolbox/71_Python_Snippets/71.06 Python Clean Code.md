---
id: 71.06
tags: [type/concept, status/evergreen, context/python]
---

# Python Clean Code

## Overview
Clean Code in Python is about writing code that is **readable, maintainable, and unsurprising**. Python's philosophy (see `import this`) already pushes in this direction — clean code is just following it consistently.

> [!INFO] Guiding principle
> *"Code is read far more often than it is written."* — readability is a first-class concern, not an afterthought.

---

## Naming

| What | Convention | Examples |
|---|---|---|
| Variables, functions | `snake_case` | `user_id`, `get_token()` |
| Classes | `PascalCase` | `UserService`, `TokenStore` |
| Constants | `UPPER_SNAKE` | `MAX_RETRIES`, `BASE_URL` |
| "Private" (internal) | `_leading_underscore` | `_build_query()` |
| Name-mangled | `__double_leading` | `__secret` (avoid in most cases) |
| Type vars | Short caps | `T`, `KT`, `VT` |

**Naming principles:**
- **Reveal intent**: `elapsed_time_in_days` not `d`
- **Avoid disinformation**: don't call a list `account_list` if it's a `dict`
- **Avoid encodings**: `user_str` → just `user`
- **Use pronounceable names**: `gen_ymdhms()` → `generate_timestamp()`
- **Domain vocabulary first**: use the same words the domain uses

```python
# ❌ Bad
def calc(u, t, r): ...

# ✅ Good
def calculate_compound_interest(principal: float, years: int, rate: float) -> float: ...
```

---

## Functions

### Rules
- **Do one thing** — if you need to describe a function with "and", split it
- **One level of abstraction per function** — don't mix high-level orchestration with low-level detail
- **Limit arguments** — 0–2 ideal; 3 borderline; >3 use a dataclass/TypedDict
- **No flag arguments** — `process(data, is_async=True)` → split into `process()`/`process_async()`
- **No side effects** — if a function has a name like `get_user`, it should NOT write to DB

```python
# ❌ Flag argument — does two things
def create_user(data: dict, send_email: bool = False): ...

# ✅ Separate concerns
def create_user(data: dict) -> User: ...
def send_welcome_email(user: User) -> None: ...
```

### Early Return (Guard Clauses)
Eliminate nesting by returning early:

```python
# ❌ Arrow anti-pattern
def process(user):
    if user:
        if user.is_active:
            if user.has_permission:
                return do_work(user)

# ✅ Guard clauses
def process(user):
    if not user:
        return None
    if not user.is_active:
        raise InactiveUserError(user.id)
    if not user.has_permission:
        raise PermissionDeniedError(user.id)
    return do_work(user)
```

---

## Classes

- **Single Responsibility**: one reason to change
- Keep classes **small and focused** — if the class name contains "And", split it
- Prefer **composition over inheritance**
- Use `@dataclass` or `@pydantic.BaseModel` for data containers
- Use `__slots__` for memory-dense objects

```python
# ❌ God class
class UserManager:
    def create_user(): ...
    def send_email(): ...
    def generate_report(): ...
    def export_to_csv(): ...

# ✅ Focused classes
class UserRepository: ...
class EmailService: ...
class UserReportGenerator: ...
```

### Dataclasses for Value Objects

```python
from dataclasses import dataclass, field

@dataclass(frozen=True)   # immutable value object
class Money:
    amount: float
    currency: str = "USD"

    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("Amount cannot be negative")
```

---

## Error Handling

- **Use exceptions, not error codes**
- **Create domain-specific exceptions** — don't raise bare `Exception`
- **Don't swallow exceptions silently**
- **Fail fast** — validate inputs at the boundary before any work is done
- **Use `contextlib.suppress` only for truly safe-to-ignore cases**

```python
# ❌ Swallowing
try:
    result = risky_operation()
except Exception:
    pass

# ✅ Domain exception + logging
class PaymentProcessingError(Exception): ...

try:
    result = process_payment(order)
except stripe.StripeError as e:
    logger.error("Stripe payment failed", extra={"order_id": order.id})
    raise PaymentProcessingError(f"Payment declined: {e}") from e
```

---

## Type Hints

Full type annotations improve IDE support, catch bugs, and serve as documentation:

```python
from typing import TypeVar, Generic
from collections.abc import Callable, Sequence

# Basic
def greet(name: str) -> str: ...

# Optional / Union (Python 3.10+)
def find_user(user_id: int) -> User | None: ...

# Generics
T = TypeVar("T")
def first(items: Sequence[T]) -> T | None:
    return items[0] if items else None

# TypedDict for structured dicts
from typing import TypedDict
class Config(TypedDict):
    host: str
    port: int
    debug: bool
```

> [!TIP] Use `from __future__ import annotations` at the top of files for deferred evaluation — avoids forward reference issues.

---

## Comments & Docstrings

**When to comment:**
- Explain **why**, not **what** (the code already shows what)
- Warn about consequences or non-obvious side effects
- Clarify intent when a workaround was necessary

**When NOT to comment:**
- Redundant descriptions (`# increment i` before `i += 1`)
- Commented-out code (use git instead)

**Docstring style (Google format):**

```python
def retry(func: Callable, max_attempts: int = 3, delay: float = 1.0) -> Any:
    """Retry a callable on failure with exponential backoff.

    Args:
        func: The callable to retry.
        max_attempts: Maximum number of attempts before raising.
        delay: Initial delay in seconds between attempts (doubles each retry).

    Returns:
        The return value of `func` on success.

    Raises:
        RetryExhaustedError: If all attempts fail.
    """
```

---

## Module & Package Structure

```
my_package/
├── __init__.py          # expose public API
├── models.py            # domain/data models
├── services.py          # business logic
├── repositories.py      # data access layer
├── exceptions.py        # custom exceptions
├── utils.py             # pure helper functions
└── config.py            # settings / env parsing
```

- Export the **public API** explicitly in `__init__.py`
- Keep `utils.py` small — if it's growing, it needs to be split into named modules
- **Avoid circular imports**: DAG-style dependency, not circular

---

## Common Anti-Patterns

| Anti-Pattern | Problem | Fix |
|---|---|---|
| Magic numbers | `if status == 3:` — what is 3? | Named constant or enum |
| Mutable default arguments | `def f(items=[])` — shared across calls | `def f(items=None): items = items or []` |
| Bare `except:` | Catches `SystemExit`, `KeyboardInterrupt` | Catch specific exceptions |
| `import *` | Pollutes namespace, breaks tooling | Explicit imports |
| God object / `utils.py` dump | No clear responsibility | Split into focused modules |
| Returning `None` + checking everywhere | Implicit null propagation | Use exceptions or `Optional` + strict callers |
| Long boolean chains | Hard to read/test | Extract to named predicate function |

---

## Quick Reference

```python
# Enumerate instead of range+index
for i, item in enumerate(items): ...

# Walrus operator for assignment in condition (3.8+)
if chunk := file.read(8192): process(chunk)

# Unpacking
first, *rest = sequence
a, b = b, a

# Context managers for resource cleanup
with open(path) as f, db.transaction() as tx: ...

# Comprehensions over loops (for simple transforms)
squares = [x**2 for x in range(10) if x % 2 == 0]

# Use str.join not concatenation in loops
result = ", ".join(str(x) for x in items)
```

## Related Concepts
- [[71_Python_Snippets_MOC]] - Parent category
- [[71.04 Google Python Style Guide]] - Google's formatting and naming conventions
- [[71.07 SOLID Principles]] - Object-oriented design principles that complement clean code
- [[71.05 Programmer Performance Micro-Techniques]] - Performance considerations after readability is achieved
