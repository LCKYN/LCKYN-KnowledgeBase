---
id: 11.08
tags: [type/concept, status/growing, context/llm]
---

# MCP Server (Model Context Protocol)

## Overview
The **Model Context Protocol (MCP)** is an open-source standard developed by Anthropic for connecting AI models to external data sources, tools, and services. MCP provides a universal interface that enables LLM applications to interact with diverse resources through a consistent protocol, eliminating the need for custom integrations for each data source.

## Core Concepts

### What is MCP?

```mermaid
graph TB
    A[LLM Application] -->|MCP Protocol| B[MCP Server]

    B --> C[Resources]
    B --> D[Tools]
    B --> E[Prompts]

    C --> F["Files<br/>Databases<br/>APIs"]
    D --> G["Functions<br/>Actions<br/>Commands"]
    E --> H["Templates<br/>Examples<br/>Instructions"]

    style A fill:#e1f5ff
    style B fill:#e1ffe1
    style C fill:#fff4e1
    style D fill:#fff4e1
    style E fill:#fff4e1
```

**Key Components:**
1. **MCP Hosts**: LLM applications (Claude Desktop, IDEs, custom apps)
2. **MCP Servers**: Services that expose resources, tools, and prompts
3. **MCP Protocol**: JSON-RPC based communication standard
4. **MCP Clients**: Libraries for connecting to MCP servers

### Architecture

```mermaid
graph LR
    A[Claude Desktop] -->|MCP Client| B[MCP Server 1<br/>GitHub]
    A -->|MCP Client| C[MCP Server 2<br/>PostgreSQL]
    A -->|MCP Client| D[MCP Server 3<br/>Google Drive]

    B --> E[Code Repos]
    C --> F[SQL Database]
    D --> G[Documents]

    style A fill:#e1f5ff
    style B fill:#e1ffe1
    style C fill:#e1ffe1
    style D fill:#e1ffe1
```

## MCP Server Components

### 1. Resources

**Definition**: Data or content that can be read by the LLM.

```mermaid
graph TD
    A[Resources] --> B[File System]
    A --> C[Database Records]
    A --> D[API Responses]
    A --> E[Documents]

    B --> F["Read files<br/>List directories<br/>Watch changes"]
    C --> G["Query results<br/>Table schemas<br/>Metadata"]
    D --> H["REST endpoints<br/>GraphQL queries<br/>Webhooks"]
    E --> I["PDFs<br/>Web pages<br/>Structured data"]

    style A fill:#e1ffe1
```

**Example Resource:**
```json
{
  "uri": "file:///project/README.md",
  "name": "Project README",
  "description": "Main documentation file",
  "mimeType": "text/markdown"
}
```

### 2. Tools

**Definition**: Functions that the LLM can invoke to perform actions.

```mermaid
graph TD
    A[Tools] --> B[Data Operations]
    A --> C[External Actions]
    A --> D[Computations]

    B --> E["CRUD operations<br/>Queries<br/>Transactions"]
    C --> F["API calls<br/>Email sending<br/>File operations"]
    D --> G["Calculations<br/>Transformations<br/>Validations"]

    style A fill:#e1ffe1
```

**Example Tool Schema:**
```json
{
  "name": "query_database",
  "description": "Execute SQL query on database",
  "inputSchema": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "SQL query to execute"
      },
      "database": {
        "type": "string",
        "description": "Database name"
      }
    },
    "required": ["query"]
  }
}
```

### 3. Prompts

**Definition**: Reusable prompt templates with dynamic parameters.

```json
{
  "name": "code_review",
  "description": "Review code changes",
  "arguments": [
    {
      "name": "file_path",
      "description": "Path to file to review",
      "required": true
    },
    {
      "name": "focus_areas",
      "description": "Specific aspects to focus on",
      "required": false
    }
  ]
}
```

## Building an MCP Server

### Python Implementation

**Using Official MCP SDK:**

```python
# install: pip install mcp
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    Resource,
    Tool,
    TextContent,
    ImageContent,
)
import asyncio

# Create server instance
app = Server("my-mcp-server")

# Register resources
@app.list_resources()
async def list_resources() -> list[Resource]:
    """List available resources."""
    return [
        Resource(
            uri="file:///data/customers.json",
            name="Customer Database",
            description="JSON file containing customer data",
            mimeType="application/json"
        ),
        Resource(
            uri="file:///data/products.json",
            name="Product Catalog",
            description="Product inventory and pricing",
            mimeType="application/json"
        )
    ]

# Read resource content
@app.read_resource()
async def read_resource(uri: str) -> str:
    """Read resource content by URI."""
    import json

    if uri == "file:///data/customers.json":
        with open("/data/customers.json", "r") as f:
            data = json.load(f)
        return json.dumps(data, indent=2)

    raise ValueError(f"Unknown resource: {uri}")

# Register tools
@app.list_tools()
async def list_tools() -> list[Tool]:
    """List available tools."""
    return [
        Tool(
            name="search_customers",
            description="Search for customers by name or email",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Max results",
                        "default": 10
                    }
                },
                "required": ["query"]
            }
        ),
        Tool(
            name="get_product_price",
            description="Get current price for a product",
            inputSchema={
                "type": "object",
                "properties": {
                    "product_id": {
                        "type": "string",
                        "description": "Product identifier"
                    }
                },
                "required": ["product_id"]
            }
        )
    ]

# Implement tool execution
@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    """Execute tool and return results."""
    import json

    if name == "search_customers":
        query = arguments["query"]
        limit = arguments.get("limit", 10)

        # Simulate customer search
        with open("/data/customers.json", "r") as f:
            customers = json.load(f)

        results = [
            c for c in customers
            if query.lower() in c["name"].lower()
            or query.lower() in c["email"].lower()
        ][:limit]

        return [TextContent(
            type="text",
            text=json.dumps(results, indent=2)
        )]

    elif name == "get_product_price":
        product_id = arguments["product_id"]

        with open("/data/products.json", "r") as f:
            products = json.load(f)

        product = next(
            (p for p in products if p["id"] == product_id),
            None
        )

        if product:
            return [TextContent(
                type="text",
                text=f"Price: ${product['price']}"
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Product {product_id} not found"
            )]

    raise ValueError(f"Unknown tool: {name}")

# Run server
async def main():
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

### Minimal MCP Server Example

```python
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent
import asyncio

app = Server("calculator-mcp")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="add",
            description="Add two numbers",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {"type": "number"},
                    "b": {"type": "number"}
                },
                "required": ["a", "b"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    if name == "add":
        result = arguments["a"] + arguments["b"]
        return [TextContent(type="text", text=str(result))]
    raise ValueError(f"Unknown tool: {name}")

async def main():
    async with stdio_server() as (read_stream, write_stream):
        await app.run(read_stream, write_stream,
                     app.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

## MCP Server Configuration

### Claude Desktop Configuration

**macOS:** `~/Library/Application Support/Claude/claude_desktop_config.json`

**Windows:** `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/Users/username/Documents"
      ]
    },
    "postgres": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-postgres",
        "postgresql://localhost/mydb"
      ]
    },
    "custom-python-server": {
      "command": "python",
      "args": [
        "/path/to/my_mcp_server.py"
      ],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
  }
}
```

### Environment Variables

```json
{
  "mcpServers": {
    "my-server": {
      "command": "python",
      "args": ["server.py"],
      "env": {
        "DATABASE_URL": "postgresql://user:pass@localhost/db",
        "API_KEY": "secret-key",
        "LOG_LEVEL": "debug"
      }
    }
  }
}
```

## Official MCP Servers

### 1. Filesystem Server

```bash
# Install
npm install -g @modelcontextprotocol/server-filesystem

# Configure
{
  "mcpServers": {
    "filesystem": {
      "command": "mcp-server-filesystem",
      "args": ["/path/to/allowed/directory"]
    }
  }
}
```

**Capabilities:**
- Read files
- List directories
- Search files
- Watch file changes

### 2. GitHub Server

```bash
npm install -g @modelcontextprotocol/server-github
```

**Configuration:**
```json
{
  "mcpServers": {
    "github": {
      "command": "mcp-server-github",
      "env": {
        "GITHUB_TOKEN": "ghp_your_token_here"
      }
    }
  }
}
```

**Capabilities:**
- Search repositories
- Read file contents
- Create issues
- Manage pull requests
- List branches/commits

### 3. PostgreSQL Server

```bash
npm install -g @modelcontextprotocol/server-postgres
```

**Configuration:**
```json
{
  "mcpServers": {
    "postgres": {
      "command": "mcp-server-postgres",
      "args": ["postgresql://user:password@localhost:5432/database"]
    }
  }
}
```

**Capabilities:**
- Execute SQL queries
- List tables/schemas
- Describe table structures
- Query metadata

### 4. Google Drive Server

```json
{
  "mcpServers": {
    "gdrive": {
      "command": "mcp-server-gdrive",
      "env": {
        "GOOGLE_APPLICATION_CREDENTIALS": "/path/to/credentials.json"
      }
    }
  }
}
```

**Capabilities:**
- List files
- Read documents
- Search Drive
- Access metadata

### 5. Slack Server

```json
{
  "mcpServers": {
    "slack": {
      "command": "mcp-server-slack",
      "env": {
        "SLACK_BOT_TOKEN": "xoxb-your-token",
        "SLACK_TEAM_ID": "T1234567"
      }
    }
  }
}
```

**Capabilities:**
- Read channels
- Send messages
- Search messages
- Manage threads

## Advanced MCP Server Patterns

### Database Integration

```python
from mcp.server import Server
from mcp.types import Resource, Tool, TextContent
import asyncpg
import asyncio

app = Server("postgres-mcp")

# Connection pool
pool = None

@app.on_initialize()
async def initialize():
    global pool
    pool = await asyncpg.create_pool(
        "postgresql://user:pass@localhost/db"
    )

@app.list_resources()
async def list_resources() -> list[Resource]:
    """List database tables as resources."""
    tables = await pool.fetch(
        "SELECT table_name FROM information_schema.tables "
        "WHERE table_schema = 'public'"
    )

    return [
        Resource(
            uri=f"postgres://tables/{row['table_name']}",
            name=row['table_name'],
            description=f"Database table: {row['table_name']}",
            mimeType="application/json"
        )
        for row in tables
    ]

@app.read_resource()
async def read_resource(uri: str) -> str:
    """Read table contents."""
    import json

    table_name = uri.split("/")[-1]
    rows = await pool.fetch(f"SELECT * FROM {table_name} LIMIT 100")

    return json.dumps([dict(row) for row in rows], indent=2)

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="execute_query",
            description="Execute SQL query",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {"type": "string"},
                    "params": {"type": "array"}
                },
                "required": ["query"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    import json

    if name == "execute_query":
        query = arguments["query"]
        params = arguments.get("params", [])

        rows = await pool.fetch(query, *params)
        result = [dict(row) for row in rows]

        return [TextContent(
            type="text",
            text=json.dumps(result, indent=2)
        )]
```

### REST API Integration

```python
from mcp.server import Server
from mcp.types import Resource, Tool, TextContent
import httpx
import asyncio

app = Server("api-mcp")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="fetch_user",
            description="Fetch user data from API",
            inputSchema={
                "type": "object",
                "properties": {
                    "user_id": {"type": "integer"}
                },
                "required": ["user_id"]
            }
        ),
        Tool(
            name="create_post",
            description="Create a new post",
            inputSchema={
                "type": "object",
                "properties": {
                    "title": {"type": "string"},
                    "body": {"type": "string"},
                    "user_id": {"type": "integer"}
                },
                "required": ["title", "body", "user_id"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    import json

    async with httpx.AsyncClient() as client:
        if name == "fetch_user":
            user_id = arguments["user_id"]
            response = await client.get(
                f"https://jsonplaceholder.typicode.com/users/{user_id}"
            )

            return [TextContent(
                type="text",
                text=json.dumps(response.json(), indent=2)
            )]

        elif name == "create_post":
            response = await client.post(
                "https://jsonplaceholder.typicode.com/posts",
                json=arguments
            )

            return [TextContent(
                type="text",
                text=f"Post created: {response.json()}"
            )]
```

### File System Watcher

```python
from mcp.server import Server
from mcp.types import Resource, TextContent
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import asyncio
import os

app = Server("file-watcher-mcp")
watched_files = {}

class FileChangeHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            watched_files[event.src_path] = "modified"

@app.list_resources()
async def list_resources() -> list[Resource]:
    """List files in watched directory."""
    directory = "/path/to/watch"
    files = []

    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        if os.path.isfile(filepath):
            files.append(Resource(
                uri=f"file://{filepath}",
                name=filename,
                description=f"File: {filename}",
                mimeType="text/plain"
            ))

    return files

@app.read_resource()
async def read_resource(uri: str) -> str:
    """Read file content."""
    filepath = uri.replace("file://", "")
    with open(filepath, "r") as f:
        return f.read()
```

## MCP Protocol Communication

### JSON-RPC Messages

```mermaid
graph LR
    A[Client] -->|Request| B[Server]
    B -->|Response| A
    B -->|Notification| A

    style A fill:#e1f5ff
    style B fill:#e1ffe1
```

**Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "search_customers",
    "arguments": {
      "query": "john",
      "limit": 5
    }
  }
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "[{\"name\": \"John Doe\", \"email\": \"john@example.com\"}]"
      }
    ]
  }
}
```

### Server Capabilities

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    },
    "tools": {},
    "prompts": {},
    "logging": {}
  }
}
```

## Security Considerations

### 1. Input Validation

```python
@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    # Validate inputs
    if name == "execute_query":
        query = arguments.get("query", "")

        # Prevent SQL injection
        if any(keyword in query.upper() for keyword in ["DROP", "DELETE", "TRUNCATE"]):
            raise ValueError("Dangerous SQL operation not allowed")

        # Limit query length
        if len(query) > 1000:
            raise ValueError("Query too long")

    # ... rest of implementation
```

### 2. Authentication

```python
import os

@app.on_initialize()
async def initialize():
    # Verify API key
    api_key = os.getenv("API_KEY")
    if not api_key:
        raise ValueError("API_KEY environment variable required")

    # Store for later use
    app.state.api_key = api_key
```

### 3. Rate Limiting

```python
from collections import defaultdict
import time

rate_limits = defaultdict(list)

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    # Rate limiting
    client_id = "default"  # Get from context
    now = time.time()

    # Remove old timestamps
    rate_limits[client_id] = [
        ts for ts in rate_limits[client_id]
        if now - ts < 60
    ]

    # Check limit (10 requests per minute)
    if len(rate_limits[client_id]) >= 10:
        raise ValueError("Rate limit exceeded")

    rate_limits[client_id].append(now)

    # ... rest of implementation
```

### 4. Sandboxing

```python
import os

@app.read_resource()
async def read_resource(uri: str) -> str:
    # Only allow reading from specific directory
    allowed_dir = "/safe/directory"
    filepath = uri.replace("file://", "")

    # Prevent directory traversal
    abs_path = os.path.abspath(filepath)
    if not abs_path.startswith(allowed_dir):
        raise ValueError("Access denied: path outside allowed directory")

    with open(abs_path, "r") as f:
        return f.read()
```

## Testing MCP Servers

### Unit Tests

```python
import pytest
from mcp.server import Server
from mcp.types import Tool, TextContent

@pytest.fixture
def server():
    return Server("test-server")

@pytest.mark.asyncio
async def test_list_tools(server):
    @server.list_tools()
    async def list_tools():
        return [Tool(name="test", description="Test tool", inputSchema={})]

    tools = await list_tools()
    assert len(tools) == 1
    assert tools[0].name == "test"

@pytest.mark.asyncio
async def test_call_tool(server):
    @server.call_tool()
    async def call_tool(name: str, arguments: dict):
        if name == "add":
            result = arguments["a"] + arguments["b"]
            return [TextContent(type="text", text=str(result))]

    result = await call_tool("add", {"a": 2, "b": 3})
    assert result[0].text == "5"
```

### Integration Tests

```python
import asyncio
from mcp.client import ClientSession
from mcp.client.stdio import stdio_client

async def test_server_integration():
    # Start server process
    server_params = ServerParams(
        command="python",
        args=["my_server.py"]
    )

    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # Initialize
            await session.initialize()

            # List tools
            tools = await session.list_tools()
            assert len(tools) > 0

            # Call tool
            result = await session.call_tool("add", {"a": 5, "b": 3})
            assert "8" in result.content[0].text

asyncio.run(test_server_integration())
```

## Best Practices

### 1. Error Handling

```python
@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    try:
        if name == "risky_operation":
            result = await perform_operation(arguments)
            return [TextContent(type="text", text=result)]
    except FileNotFoundError as e:
        return [TextContent(
            type="text",
            text=f"Error: File not found - {str(e)}"
        )]
    except PermissionError as e:
        return [TextContent(
            type="text",
            text=f"Error: Permission denied - {str(e)}"
        )]
    except Exception as e:
        return [TextContent(
            type="text",
            text=f"Error: Unexpected error - {str(e)}"
        )]
```

### 2. Logging

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    logger.info(f"Tool called: {name} with args: {arguments}")

    try:
        result = await execute_tool(name, arguments)
        logger.info(f"Tool {name} succeeded")
        return result
    except Exception as e:
        logger.error(f"Tool {name} failed: {str(e)}")
        raise
```

### 3. Caching

```python
from functools import lru_cache
import time

cache = {}
CACHE_TTL = 300  # 5 minutes

@app.read_resource()
async def read_resource(uri: str) -> str:
    # Check cache
    if uri in cache:
        cached_data, timestamp = cache[uri]
        if time.time() - timestamp < CACHE_TTL:
            return cached_data

    # Fetch fresh data
    data = await fetch_resource(uri)

    # Update cache
    cache[uri] = (data, time.time())

    return data
```

### 4. Documentation

```python
@app.list_tools()
async def list_tools() -> list[Tool]:
    """
    List all available tools.

    Returns:
        List of Tool objects with detailed schemas.
    """
    return [
        Tool(
            name="process_data",
            description=(
                "Process data with specified transformation. "
                "Supports JSON, CSV, and XML formats. "
                "Max input size: 10MB."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "data": {
                        "type": "string",
                        "description": "Input data to process"
                    },
                    "format": {
                        "type": "string",
                        "enum": ["json", "csv", "xml"],
                        "description": "Data format"
                    },
                    "operation": {
                        "type": "string",
                        "enum": ["validate", "transform", "summarize"],
                        "description": "Operation to perform"
                    }
                },
                "required": ["data", "format", "operation"]
            }
        )
    ]
```

## Use Cases

### ✅ Ideal For
- **Data Integration**: Connect LLMs to databases, APIs, file systems
- **Tool Augmentation**: Extend LLM capabilities with custom functions
- **Enterprise Systems**: Integrate with internal tools and services
- **Development Tools**: IDE integrations, code analysis, CI/CD
- **Knowledge Bases**: Access documentation, wikis, knowledge graphs
- **Automation**: Trigger workflows, execute commands

### ❌ Not Ideal For
- **High-latency operations**: Real-time streaming not optimized
- **Binary data**: Text-focused protocol
- **Complex state management**: Stateless by design
- **Direct LLM fine-tuning**: Not a training framework

## Comparison with Alternatives

| Feature | MCP | [[11.03 LLM Tool Calls\|Function Calling]] | [[11.02 LLM Agents\|Agents]] |
|---------|-----|---------------------|--------|
| **Standardization** | ✅ Universal protocol | Provider-specific | Framework-specific |
| **Reusability** | ✅ One server, many clients | Per-application | Per-agent |
| **Type Safety** | ✅ JSON Schema | ✅ Schema validation | Varies |
| **Resources** | ✅ Built-in | ❌ Manual | Varies |
| **Prompts** | ✅ Built-in | ❌ Manual | ✅ Often included |
| **Deployment** | Separate process | Embedded | Embedded |

## Related Concepts
- [[11.02 LLM Agents]]
- [[11.03 LLM Tool Calls]]
- [[11.04 LLM Workflows]]
- API Integration (to be added)
- JSON-RPC Protocol (to be added)
- Service-Oriented Architecture (to be added)

## References
- [Model Context Protocol Documentation](https://modelcontextprotocol.io/)
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)
- [MCP Specification](https://spec.modelcontextprotocol.io/)
- [Anthropic MCP Announcement](https://www.anthropic.com/news/model-context-protocol)
- [Official MCP Servers](https://github.com/modelcontextprotocol/servers)
