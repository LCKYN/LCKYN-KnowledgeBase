---
id: 11.25
tags: [type/concept, status/evergreen, context/llm, context/dev-tools]
---

# Writing Code That AI Assistants Understand

## Overview
AI coding assistants (GitHub Copilot, Cursor, Continue.dev) work by **indexing your codebase** and pulling relevant context into a limited context window. The quality of their suggestions is directly proportional to the **clarity of the code they can see**. Clean code practices — naming, SRP, type hints, docstrings — are not just human readability improvements; they are **signals that LLMs read to understand intent**.

> [!INFO] The mental model
> Think of Copilot as a very smart developer who can only see:
> 1. The current file (full)
> 2. A few semantically similar files from the workspace index
> 3. Your imports and type signatures
>
> Everything it *can't* see, it guesses. The less it has to guess, the better its output.

---

## How AI Assistants Use Your Code

```
Your codebase
     │
     ▼
Workspace index (embeddings + symbol map)
     │
     ▼  (at suggestion time)
Context assembly:
  - Current file (always)
  - Cursor position + surrounding code
  - Top-k semantically similar chunks
  - Open editor tabs
  - Import graph (what this file depends on)
     │
     ▼
~8K–32K token context window → LLM → suggestion
```

Everything outside the assembled context is invisible. **Your code structure determines what gets assembled.**

---

## How Clean Code Improves AI Suggestions

### 1. Naming → Better Semantic Retrieval

The workspace index is built from **embeddings of your code text**. Descriptive names produce stronger, more discriminative embeddings.

| Code Quality | Embedding Quality | Effect on Suggestions |
|---|---|---|
| `def calc(u, t, r):` | Weak — generic tokens | Copilot retrieves unrelated chunks as "similar" |
| `def calculate_compound_interest(principal, years, rate):` | Strong — domain-specific | Retrieves finance-related code; suggestions match domain |

```python
# ❌ Copilot has no signal about what this does
def proc(d, f, t):
    return d * f ** t

# ✅ Copilot completes the body correctly and suggests related functions
def calculate_future_value(present_value: float, rate: float, periods: int) -> float:
```

### 2. Type Annotations → Accurate Type Inference

Type hints are read directly by Copilot's context. Without them, Copilot guesses types — and guesses wrong in complex codebases.

```python
# ❌ Copilot doesn't know what `user` is — generic suggestions
def process(user, config):
    ...

# ✅ Copilot knows the shape of both objects — precise suggestions
def process(user: UserProfile, config: ProcessingConfig) -> ProcessingResult:
    ...
```

**Return type annotations** matter most — they tell Copilot what downstream code can do with the output.

### 3. Docstrings → Intent Without Ambiguity

Docstrings are the clearest signal of intent. With a docstring, Copilot completes the *correct* implementation; without one, it infers from name alone.

```python
def chunk_text(text: str, size: int, overlap: int) -> list[str]:
    """Split text into overlapping chunks for embedding.

    Args:
        text: Input document text.
        size: Maximum tokens per chunk.
        overlap: Number of tokens to repeat between consecutive chunks.

    Returns:
        List of text chunks with overlap applied.
    """
    # Copilot will generate the correct sliding window implementation here
```

### 4. SRP (Single Responsibility) → Entire Function Fits in Context

Copilot works best when it can see a **complete, coherent unit**. A 500-line function with multiple concerns means Copilot only sees part of the logic.

| Function size | Context window coverage | Suggestion quality |
|---|---|---|
| 10–30 lines | Entire function visible | High — full context |
| 50–100 lines | Mostly visible | Good |
| 200+ lines | Partial — top or bottom | Degraded — misses dependencies |

> [!TIP] Keep functions short enough to fit completely in view
> SRP isn't just about maintainability — it's about making sure Copilot always has the **complete picture** of what a function does.

### 5. Consistent Patterns → Copilot Learns Your Style

Copilot infers your style from your codebase. Consistency means it completes *your* pattern, not a generic one.

```python
# If your codebase consistently does this:
class UserRepository:
    def get_by_id(self, user_id: int) -> User | None: ...
    def get_all(self, *, active_only: bool = False) -> list[User]: ...
    def create(self, data: UserCreateSchema) -> User: ...

# Copilot will suggest matching signatures for new repositories:
class OrderRepository:
    def get_by_id(self, order_id: int) -> Order | None: ...   # ← suggested
    def get_all(self, *, status: OrderStatus | None = None) -> list[Order]: ...  # ← suggested
```

### 6. Small, Focused Files → Full File in Context Window

Copilot always includes the **current file in full**. A 2000-line file means much of it is irrelevant noise in the context, diluting useful signal.

```
Current file: 80 lines (focused module)
→ 100% of file is signal
→ Copilot has complete picture

Current file: 1500 lines (God module)
→ Context window truncated
→ Copilot misses imports, class definitions, or helper functions
```

**Rule of thumb**: keep files under ~300 lines. Split by responsibility.

### 7. Named Constants → Domain Comprehension

```python
# ❌ Magic numbers — Copilot doesn't know what 86400 means
if elapsed > 86400:
    refresh_token()

# ✅ Named constants — Copilot understands the domain and suggests correct related constants
SECONDS_PER_DAY = 86400
TOKEN_EXPIRY_SECONDS = 7 * SECONDS_PER_DAY

if elapsed > TOKEN_EXPIRY_SECONDS:
    refresh_token()
```

### 8. Interface/Protocol Definitions → Complete Type Context

When you define `Protocol` or `ABC`, Copilot uses those contracts when generating implementations:

```python
class VectorStore(Protocol):
    def upsert(self, id: str, vector: list[float], metadata: dict) -> None: ...
    def search(self, query: list[float], top_k: int) -> list[SearchResult]: ...
    def delete(self, id: str) -> None: ...

# Copilot will correctly implement all three methods when you write:
class ChromaVectorStore(VectorStore):
    ...  # ← Copilot fills this in correctly
```

---

## Practical Checklist

Before writing a new module, set these signals up first — Copilot completions will be dramatically better:

- [ ] **File has a clear, single purpose** — state it in a module-level docstring
- [ ] **Import what you use** — don't wildcard import; Copilot follows import chains
- [ ] **Define types first** — Pydantic models, TypedDicts, dataclasses at the top of the file
- [ ] **Write function signatures + docstrings before the body** — Copilot completes the implementation
- [ ] **Name things with domain vocabulary** — not `process()` but `reconcile_invoice()`
- [ ] **Keep related files open** — Copilot includes open editor tabs in context

---

## Anti-Patterns That Degrade AI Suggestions

| Anti-Pattern | Why It Hurts Copilot | Fix |
|---|---|---|
| Single-letter variables (`x`, `d`, `tmp`) | No semantic signal for embeddings | Descriptive names |
| Missing type annotations | Copilot guesses wrong types in complex codebases | Annotate all signatures |
| `**kwargs` everywhere | Copilot can't infer what arguments exist | Explicit typed parameters |
| Large files (1000+ lines) | Context window truncation, diluted signal | Split by responsibility |
| No docstrings | Copilot infers intent from name alone | Write docstrings before body |
| Inconsistent patterns | Copilot picks a random pattern, not yours | Establish and follow conventions |
| Commented-out code blocks | Pollutes context with dead signal | Delete; use git |
| Magic numbers and booleans | Domain context lost | Named constants and enums |

---

## Workflow: Signature-First Development

Write the **contract** before the **implementation**. Copilot excels at filling in implementations when the intent is fully specified:

```python
# Step 1: Write the type models
class ChunkingConfig(BaseModel):
    chunk_size: int = 512
    overlap: int = 64
    strategy: Literal["fixed", "sentence", "semantic"] = "fixed"

# Step 2: Write the signature + docstring (no body yet)
def chunk_document(text: str, config: ChunkingConfig) -> list[Chunk]:
    """Split document into overlapping chunks according to config.

    Uses the specified strategy:
    - fixed: equal-size token windows with overlap
    - sentence: split on sentence boundaries
    - semantic: split where embedding similarity drops

    Returns:
        List of Chunk objects with text, start_char, end_char, metadata.
    """
    # Step 3: Trigger Copilot here — it has everything it needs
```

---

## Summary

| Practice | Human Benefit | AI Benefit |
|---|---|---|
| Descriptive naming | Readable | Better semantic retrieval |
| Type annotations | IDE support | Accurate type inference in suggestions |
| Docstrings | Self-documenting | Intent signal → correct implementations |
| Small functions (SRP) | Maintainable | Fits in context window completely |
| Small focused files | Navigable | Full file fits as context |
| Consistent patterns | Predictable | Copilot matches your style |
| Named constants | No magic numbers | Domain comprehension |
| Protocol/ABC definitions | Contract-driven | Correct implementation generation |

## Related Concepts
- [[11_LLM_Dev_MOC]] - Parent category
- [[11.23 Workspace Indexing]] - How the workspace index is built and queried
- [[11.16 Context Window Management]] - Context window limits and what gets included
- [[71.06 Python Clean Code]] - The clean code practices themselves
- [[71.07 SOLID Principles]] - SRP and DIP especially relevant to AI-friendliness
- [[11.14 Prompt Engineering]] - Docstrings and signatures function as implicit prompts
